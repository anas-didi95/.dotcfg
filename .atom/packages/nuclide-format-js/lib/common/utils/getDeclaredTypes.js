'use strict';

var _jscodeshift = require('jscodeshift');

var _jscodeshift2 = _interopRequireDefault(_jscodeshift);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CONFIG = [{
  nodeType: _jscodeshift2.default.ImportDeclaration,
  filters: [function (path) {
    return path.value.importKind === 'type' || path.value.importKind === 'typeof';
  }],
  getNodes: function getNodes(path) {
    return path.node.specifiers.map(function (specifier) {
      return specifier.local;
    });
  }
}, {
  nodeType: _jscodeshift2.default.TypeAlias,
  filters: [],
  getNodes: function getNodes(path) {
    return [path.node.id];
  }
}, {
  nodeType: _jscodeshift2.default.TypeParameterDeclaration,
  filters: [],
  getNodes: function getNodes(path) {
    return path.node.params;
  }
},

// TODO: remove these, they should be covered by TypeParameterDeclaration
// but there is a bug in jscodeshift
{
  nodeType: _jscodeshift2.default.ClassDeclaration,
  filters: [function (path) {
    return path.node.typeParameters && Array.isArray(path.node.typeParameters.params);
  }],
  getNodes: function getNodes(path) {
    return path.node.typeParameters.params;
  }
}];

/**
 * This will get a list of all flow types that are declared within root's AST
 */
/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 *
 * 
 */

function getDeclaredTypes(root, options, filters) {
  // Start with the built in types that are always declared.
  var moduleMap = options.moduleMap;

  var ids = new Set(moduleMap.getBuiltInTypes());
  var visitor = {};
  CONFIG.forEach(function (config) {
    visitor['visit' + config.nodeType] = function (path) {
      if ((!filters || filters.every(function (filter) {
        return filter(path);
      })) && config.filters.every(function (filter) {
        return filter(path);
      })) {
        var nodes = config.getNodes(path);
        nodes.forEach(function (node) {
          if (_jscodeshift2.default.Identifier.check(node) || _jscodeshift2.default.TypeParameter.check(node)) {
            ids.add(node.name);
          }
        });
      }
      this.traverse(path);
    };
  });
  _jscodeshift2.default.types.visit(root.nodes()[0], visitor);
  return ids;
}

module.exports = getDeclaredTypes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vdXRpbHMvZ2V0RGVjbGFyZWRUeXBlcy5qcyJdLCJuYW1lcyI6WyJDT05GSUciLCJub2RlVHlwZSIsIkltcG9ydERlY2xhcmF0aW9uIiwiZmlsdGVycyIsInBhdGgiLCJ2YWx1ZSIsImltcG9ydEtpbmQiLCJnZXROb2RlcyIsIm5vZGUiLCJzcGVjaWZpZXJzIiwibWFwIiwic3BlY2lmaWVyIiwibG9jYWwiLCJUeXBlQWxpYXMiLCJpZCIsIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiIsInBhcmFtcyIsIkNsYXNzRGVjbGFyYXRpb24iLCJ0eXBlUGFyYW1ldGVycyIsIkFycmF5IiwiaXNBcnJheSIsImdldERlY2xhcmVkVHlwZXMiLCJyb290Iiwib3B0aW9ucyIsIm1vZHVsZU1hcCIsImlkcyIsIlNldCIsImdldEJ1aWx0SW5UeXBlcyIsInZpc2l0b3IiLCJmb3JFYWNoIiwiY29uZmlnIiwiZXZlcnkiLCJmaWx0ZXIiLCJub2RlcyIsIklkZW50aWZpZXIiLCJjaGVjayIsIlR5cGVQYXJhbWV0ZXIiLCJhZGQiLCJuYW1lIiwidHJhdmVyc2UiLCJ0eXBlcyIsInZpc2l0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFhQTs7Ozs7O0FBUUEsSUFBTUEsU0FBNkIsQ0FDakM7QUFDRUMsWUFBVSxzQkFBS0MsaUJBRGpCO0FBRUVDLFdBQVMsQ0FDUDtBQUFBLFdBQVFDLEtBQUtDLEtBQUwsQ0FBV0MsVUFBWCxLQUEwQixNQUExQixJQUNORixLQUFLQyxLQUFMLENBQVdDLFVBQVgsS0FBMEIsUUFENUI7QUFBQSxHQURPLENBRlg7QUFNRUMsWUFBVTtBQUFBLFdBQVFILEtBQUtJLElBQUwsQ0FBVUMsVUFBVixDQUFxQkMsR0FBckIsQ0FBeUI7QUFBQSxhQUFhQyxVQUFVQyxLQUF2QjtBQUFBLEtBQXpCLENBQVI7QUFBQTtBQU5aLENBRGlDLEVBU2pDO0FBQ0VYLFlBQVUsc0JBQUtZLFNBRGpCO0FBRUVWLFdBQVMsRUFGWDtBQUdFSSxZQUFVO0FBQUEsV0FBUSxDQUFDSCxLQUFLSSxJQUFMLENBQVVNLEVBQVgsQ0FBUjtBQUFBO0FBSFosQ0FUaUMsRUFjakM7QUFDRWIsWUFBVSxzQkFBS2Msd0JBRGpCO0FBRUVaLFdBQVMsRUFGWDtBQUdFSSxZQUFVO0FBQUEsV0FBUUgsS0FBS0ksSUFBTCxDQUFVUSxNQUFsQjtBQUFBO0FBSFosQ0FkaUM7O0FBb0JqQztBQUNBO0FBQ0E7QUFDRWYsWUFBVSxzQkFBS2dCLGdCQURqQjtBQUVFZCxXQUFTLENBQ1A7QUFBQSxXQUNFQyxLQUFLSSxJQUFMLENBQVVVLGNBQVYsSUFDQUMsTUFBTUMsT0FBTixDQUFjaEIsS0FBS0ksSUFBTCxDQUFVVSxjQUFWLENBQXlCRixNQUF2QyxDQUZGO0FBQUEsR0FETyxDQUZYO0FBUUVULFlBQVU7QUFBQSxXQUFRSCxLQUFLSSxJQUFMLENBQVVVLGNBQVYsQ0FBeUJGLE1BQWpDO0FBQUE7QUFSWixDQXRCaUMsQ0FBbkM7O0FBa0NBOzs7QUF2REE7Ozs7Ozs7Ozs7QUEwREEsU0FBU0ssZ0JBQVQsQ0FDRUMsSUFERixFQUVFQyxPQUZGLEVBR0VwQixPQUhGLEVBSWU7QUFDYjtBQURhLE1BRU5xQixTQUZNLEdBRU9ELE9BRlAsQ0FFTkMsU0FGTTs7QUFHYixNQUFNQyxNQUFNLElBQUlDLEdBQUosQ0FBUUYsVUFBVUcsZUFBVixFQUFSLENBQVo7QUFDQSxNQUFNQyxVQUFVLEVBQWhCO0FBQ0E1QixTQUFPNkIsT0FBUCxDQUFlLGtCQUFVO0FBQ3ZCRCxzQkFBZ0JFLE9BQU83QixRQUF2QixJQUFxQyxVQUFTRyxJQUFULEVBQWU7QUFDbEQsVUFDRSxDQUFDLENBQUNELE9BQUQsSUFBWUEsUUFBUTRCLEtBQVIsQ0FBYztBQUFBLGVBQVVDLE9BQU81QixJQUFQLENBQVY7QUFBQSxPQUFkLENBQWIsS0FDQTBCLE9BQU8zQixPQUFQLENBQWU0QixLQUFmLENBQXFCO0FBQUEsZUFBVUMsT0FBTzVCLElBQVAsQ0FBVjtBQUFBLE9BQXJCLENBRkYsRUFHRTtBQUNBLFlBQU02QixRQUFRSCxPQUFPdkIsUUFBUCxDQUFnQkgsSUFBaEIsQ0FBZDtBQUNBNkIsY0FBTUosT0FBTixDQUFjLGdCQUFRO0FBQ3BCLGNBQUksc0JBQUtLLFVBQUwsQ0FBZ0JDLEtBQWhCLENBQXNCM0IsSUFBdEIsS0FBK0Isc0JBQUs0QixhQUFMLENBQW1CRCxLQUFuQixDQUF5QjNCLElBQXpCLENBQW5DLEVBQW1FO0FBQ2pFaUIsZ0JBQUlZLEdBQUosQ0FBUTdCLEtBQUs4QixJQUFiO0FBQ0Q7QUFDRixTQUpEO0FBS0Q7QUFDRCxXQUFLQyxRQUFMLENBQWNuQyxJQUFkO0FBQ0QsS0FiRDtBQWNELEdBZkQ7QUFnQkEsd0JBQUtvQyxLQUFMLENBQVdDLEtBQVgsQ0FBaUJuQixLQUFLVyxLQUFMLEdBQWEsQ0FBYixDQUFqQixFQUFrQ0wsT0FBbEM7QUFDQSxTQUFPSCxHQUFQO0FBQ0Q7O0FBRURpQixPQUFPQyxPQUFQLEdBQWlCdEIsZ0JBQWpCIiwiZmlsZSI6ImdldERlY2xhcmVkVHlwZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgdHlwZSB7Q29sbGVjdGlvbiwgTm9kZSwgTm9kZVBhdGh9IGZyb20gJy4uL3R5cGVzL2FzdCc7XG5pbXBvcnQgdHlwZSB7U291cmNlT3B0aW9uc30gZnJvbSAnLi4vb3B0aW9ucy9Tb3VyY2VPcHRpb25zJztcblxuaW1wb3J0IGpzY3MgZnJvbSAnanNjb2Rlc2hpZnQnO1xuXG50eXBlIENvbmZpZ0VudHJ5ID0ge1xuICBub2RlVHlwZTogc3RyaW5nLFxuICBmaWx0ZXJzOiBBcnJheTwocGF0aDogTm9kZVBhdGgpID0+IGJvb2xlYW4+LFxuICBnZXROb2RlczogKHBhdGg6IE5vZGVQYXRoKSA9PiBBcnJheTxOb2RlPixcbn07XG5cbmNvbnN0IENPTkZJRzogQXJyYXk8Q29uZmlnRW50cnk+ID0gW1xuICB7XG4gICAgbm9kZVR5cGU6IGpzY3MuSW1wb3J0RGVjbGFyYXRpb24sXG4gICAgZmlsdGVyczogW1xuICAgICAgcGF0aCA9PiBwYXRoLnZhbHVlLmltcG9ydEtpbmQgPT09ICd0eXBlJyB8fFxuICAgICAgICBwYXRoLnZhbHVlLmltcG9ydEtpbmQgPT09ICd0eXBlb2YnLFxuICAgIF0sXG4gICAgZ2V0Tm9kZXM6IHBhdGggPT4gcGF0aC5ub2RlLnNwZWNpZmllcnMubWFwKHNwZWNpZmllciA9PiBzcGVjaWZpZXIubG9jYWwpLFxuICB9LFxuICB7XG4gICAgbm9kZVR5cGU6IGpzY3MuVHlwZUFsaWFzLFxuICAgIGZpbHRlcnM6IFtdLFxuICAgIGdldE5vZGVzOiBwYXRoID0+IFtwYXRoLm5vZGUuaWRdLFxuICB9LFxuICB7XG4gICAgbm9kZVR5cGU6IGpzY3MuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uLFxuICAgIGZpbHRlcnM6IFtdLFxuICAgIGdldE5vZGVzOiBwYXRoID0+IHBhdGgubm9kZS5wYXJhbXMsXG4gIH0sXG5cbiAgLy8gVE9ETzogcmVtb3ZlIHRoZXNlLCB0aGV5IHNob3VsZCBiZSBjb3ZlcmVkIGJ5IFR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblxuICAvLyBidXQgdGhlcmUgaXMgYSBidWcgaW4ganNjb2Rlc2hpZnRcbiAge1xuICAgIG5vZGVUeXBlOiBqc2NzLkNsYXNzRGVjbGFyYXRpb24sXG4gICAgZmlsdGVyczogW1xuICAgICAgcGF0aCA9PiAoXG4gICAgICAgIHBhdGgubm9kZS50eXBlUGFyYW1ldGVycyAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHBhdGgubm9kZS50eXBlUGFyYW1ldGVycy5wYXJhbXMpXG4gICAgICApLFxuICAgIF0sXG4gICAgZ2V0Tm9kZXM6IHBhdGggPT4gcGF0aC5ub2RlLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcyxcbiAgfSxcbl07XG5cbi8qKlxuICogVGhpcyB3aWxsIGdldCBhIGxpc3Qgb2YgYWxsIGZsb3cgdHlwZXMgdGhhdCBhcmUgZGVjbGFyZWQgd2l0aGluIHJvb3QncyBBU1RcbiAqL1xuZnVuY3Rpb24gZ2V0RGVjbGFyZWRUeXBlcyhcbiAgcm9vdDogQ29sbGVjdGlvbixcbiAgb3B0aW9uczogU291cmNlT3B0aW9ucyxcbiAgZmlsdGVycz86ID9BcnJheTwocGF0aDogTm9kZVBhdGgpID0+IGJvb2xlYW4+LFxuKTogU2V0PHN0cmluZz4ge1xuICAvLyBTdGFydCB3aXRoIHRoZSBidWlsdCBpbiB0eXBlcyB0aGF0IGFyZSBhbHdheXMgZGVjbGFyZWQuXG4gIGNvbnN0IHttb2R1bGVNYXB9ID0gb3B0aW9ucztcbiAgY29uc3QgaWRzID0gbmV3IFNldChtb2R1bGVNYXAuZ2V0QnVpbHRJblR5cGVzKCkpO1xuICBjb25zdCB2aXNpdG9yID0ge307XG4gIENPTkZJRy5mb3JFYWNoKGNvbmZpZyA9PiB7XG4gICAgdmlzaXRvcltgdmlzaXQke2NvbmZpZy5ub2RlVHlwZX1gXSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKCFmaWx0ZXJzIHx8IGZpbHRlcnMuZXZlcnkoZmlsdGVyID0+IGZpbHRlcihwYXRoKSkpICYmXG4gICAgICAgIGNvbmZpZy5maWx0ZXJzLmV2ZXJ5KGZpbHRlciA9PiBmaWx0ZXIocGF0aCkpXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBjb25maWcuZ2V0Tm9kZXMocGF0aCk7XG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgaWYgKGpzY3MuSWRlbnRpZmllci5jaGVjayhub2RlKSB8fCBqc2NzLlR5cGVQYXJhbWV0ZXIuY2hlY2sobm9kZSkpIHtcbiAgICAgICAgICAgIGlkcy5hZGQobm9kZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy50cmF2ZXJzZShwYXRoKTtcbiAgICB9O1xuICB9KTtcbiAganNjcy50eXBlcy52aXNpdChyb290Lm5vZGVzKClbMF0sIHZpc2l0b3IpO1xuICByZXR1cm4gaWRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldERlY2xhcmVkVHlwZXM7XG4iXX0=