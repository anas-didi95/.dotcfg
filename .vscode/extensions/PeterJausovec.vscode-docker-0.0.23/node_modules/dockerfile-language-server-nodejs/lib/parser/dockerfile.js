/* --------------------------------------------------------------------------------------------
 * Copyright (c) Remy Suen. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const imageTemplate_1 = require("./imageTemplate");
const docker_1 = require("../docker");
class Dockerfile extends imageTemplate_1.ImageTemplate {
    constructor() {
        super(...arguments);
        this.initialInstructions = new imageTemplate_1.ImageTemplate();
        this.buildStages = [];
        this.directive = null;
        /**
         * Whether a FROM instruction has been added to this Dockerfile or not.
         */
        this.foundFrom = false;
    }
    getEscapeCharacter() {
        if (this.directive !== null && this.directive.getDirective() === docker_1.DIRECTIVE_ESCAPE) {
            let value = this.directive.getValue();
            if (value === '\\' || value === '`') {
                return value;
            }
        }
        return '\\';
    }
    getInitialARGs() {
        return this.initialInstructions.getARGs();
    }
    getContainingImage(position) {
        for (let buildStage of this.buildStages) {
            if (buildStage.contains(position)) {
                return buildStage;
            }
        }
        return this.initialInstructions;
    }
    addInstruction(instruction) {
        if (instruction.getKeyword() === "FROM") {
            this.currentBuildStage = new imageTemplate_1.ImageTemplate();
            this.buildStages.push(this.currentBuildStage);
            this.foundFrom = true;
        }
        else if (!this.foundFrom) {
            this.initialInstructions.addInstruction(instruction);
        }
        if (this.foundFrom) {
            this.currentBuildStage.addInstruction(instruction);
        }
        super.addInstruction(instruction);
    }
    setDirective(directive) {
        this.directive = directive;
    }
    getDirective() {
        return this.directive;
    }
    getVariableNames(currentLine) {
        let variables = [
            "FTP_PROXY", "ftp_proxy",
            "HTTP_PROXY", "http_proxy",
            "HTTPS_PROXY", "https_proxy",
            "NO_PROXY", "no_proxy"
        ];
        for (let arg of this.getARGs()) {
            if (arg.isBefore(currentLine)) {
                const property = arg.getProperty();
                if (property) {
                    const variable = property.getName();
                    if (variables.indexOf(variable) === -1) {
                        variables.push(variable);
                    }
                }
            }
        }
        for (let env of this.getENVs()) {
            if (env.isBefore(currentLine)) {
                for (let property of env.getProperties()) {
                    let variable = property.getName();
                    if (variables.indexOf(variable) === -1) {
                        variables.push(variable);
                    }
                }
            }
        }
        variables.sort((a, b) => {
            if (a.toLowerCase() === b.toLowerCase()) {
                // put uppercase variables first
                return a.localeCompare(b) * -1;
            }
            return a.localeCompare(b);
        });
        return variables;
    }
    getVariableValue(variable, line) {
        let envs = this.getENVs();
        for (let i = envs.length - 1; i >= 0; i--) {
            if (envs[i].isBefore(line)) {
                for (let property of envs[i].getProperties()) {
                    if (property.getName() === variable) {
                        return property.getValue();
                    }
                }
            }
        }
        let args = this.getARGs();
        for (let i = args.length - 1; i >= 0; i--) {
            if (args[i].isBefore(line)) {
                let property = args[i].getProperty();
                if (property && property.getName() === variable) {
                    return property.getValue();
                }
            }
        }
        return undefined;
    }
}
exports.Dockerfile = Dockerfile;
